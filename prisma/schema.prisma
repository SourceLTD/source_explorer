generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL")
  directUrl = env("POSTGRES_URL_NON_POOLING")
}

model LexicalEntry {
  id                String                   @id
  legacy_id         String
  gloss             String
  pos               String                   @db.Char(1)
  lexfile           String
  isMwe             Boolean                  @default(false) @map("is_mwe")
  transitive        Boolean?
  lemmas            String[]                 @default([])
  src_lemmas        String[]                 @default([])
  particles         String[]                 @default([])
  frames            String[]                 @default([])
  examples          String[]                 @default([])
  glossTsv          Unsupported("tsvector")? @map("gloss_tsv")
  examplesTsv       Unsupported("tsvector")? @map("examples_tsv")
  createdAt         DateTime                 @default(now()) @map("created_at")
  updatedAt         DateTime                 @default(now()) @updatedAt @map("updated_at")
  flagged           Boolean?                 @default(false)
  flaggedReason     String?                  @map("flagged_reason")
  forbidden         Boolean?                 @default(false)
  forbiddenReason   String?                  @map("forbidden_reason")
  frame_id          String?
  vendler_class     vendler_class_type?
  legal_gloss       String?
  legal_constraints String[]
  sourceRelations   EntryRelation[]          @relation("SourceEntry")
  targetRelations   EntryRelation[]          @relation("TargetEntry")
  frame             frames?                  @relation(fields: [frame_id], references: [id])
  roles             roles[]

  @@unique([id, frame_id], map: "uq_lex_entry_id_frame")
  @@index([examplesTsv], map: "idx_lex_examples_tsv", type: Gin)
  @@index([frames], map: "idx_lex_frames_gin", type: Gin)
  @@index([glossTsv], map: "idx_lex_gloss_tsv", type: Gin)
  @@index([lemmas], map: "idx_lex_lemmas_gin", type: Gin)
  @@index([particles], map: "idx_lex_particles_gin", type: Gin)
  @@index([pos], map: "idx_lex_pos")
  @@index([vendler_class], map: "idx_lex_vendler_class")
  @@index([frame_id], map: "idx_lex_frame")
  @@map("lexical_entries")
}

model EntryRelation {
  sourceId String       @map("source_id")
  targetId String       @map("target_id")
  type     RelationType
  source   LexicalEntry @relation("SourceEntry", fields: [sourceId], references: [id], onDelete: Cascade)
  target   LexicalEntry @relation("TargetEntry", fields: [targetId], references: [id], onDelete: Cascade)

  @@id([sourceId, type, targetId])
  @@index([targetId, type], map: "idx_rel_target_type")
  @@map("entry_relations")
}

model frame_roles {
  id           String     @id
  frame_id     String
  role_type_id String
  created_at   DateTime   @default(now())
  updated_at   DateTime   @default(now())
  frames       frames     @relation(fields: [frame_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  role_types   role_types @relation(fields: [role_type_id], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@unique([frame_id, role_type_id], map: "uq_frame_role")
  @@unique([id, frame_id], map: "uq_frame_roles_id_frame")
  @@index([frame_id], map: "idx_frame_roles_frame")
  @@index([role_type_id], map: "idx_frame_roles_role_type")
}

model frames {
  id                             String         @id
  framebank_id                   String         @unique
  frame_name                     String
  definition                     String
  prototypical_synset            String
  prototypical_synset_definition String
  short_definition               String
  is_supporting_frame            Boolean        @default(false)
  created_at                     DateTime       @default(now())
  updated_at                     DateTime       @default(now())
  communication                  Boolean?
  frame_roles                    frame_roles[]
  lexical_entries                LexicalEntry[]

  @@index([framebank_id], map: "idx_framebank_id")
  @@index([frame_name], map: "idx_frames_frame_name")
  @@index([is_supporting_frame], map: "idx_frames_is_supporting")
}

model instantiation_types {
  id          String  @id
  label       String  @unique
  wikidata_id String? @unique
}

model role_types {
  id                  String        @id
  label               String        @unique
  generic_description String
  explanation         String?
  frame_roles         frame_roles[]
  roles               roles[]
}

model roles {
  id                     String       @id @db.VarChar(255)
  lexical_entry_id       String       @db.VarChar(255)
  role_type_id           String       @db.VarChar(255)
  main                   Boolean      @default(false)
  description            String?
  example_sentence       String?
  instantiation_type_ids String[]     @default([]) @db.VarChar(255)
  created_at             DateTime     @default(now()) @db.Timestamp(6)
  updated_at             DateTime     @default(now()) @db.Timestamp(6)
  lexical_entries        LexicalEntry @relation(fields: [lexical_entry_id], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_roles_lexical_entry")
  role_types             role_types   @relation(fields: [role_type_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_roles_role_type")

  @@index([instantiation_type_ids], map: "idx_roles_inst_types", type: Gin)
  @@index([lexical_entry_id], map: "idx_roles_lexical_entry")
  @@index([main], map: "idx_roles_main")
  @@index([role_type_id], map: "idx_roles_role_type")
}

enum RelationType {
  also_see
  causes
  entails
  hypernym
  hyponym

  @@map("relation_type")
}

enum vendler_class_type {
  state
  activity
  accomplishment
  achievement
}
